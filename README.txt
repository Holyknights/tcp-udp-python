这个是网络实验的程序
用python实现UDP和TCP的server和Client
文件：
tcp_client&server：已经符合要求的tcp client&server
udp_client&server：基础的udp server&server
udp_sn&cn：目前完成用户名和密码的验证，传输文件部分还有问题
理论上完整功能：
先打开server再打开client
在client中输入用户名，输入正确进入输入密码环节
输入错误则提示用户名错误
输入密码环节同理
完成验证后，client可向server发送消息
或从server下载文件（目前只设计了固定名字file1.docx和file2.docx）
实验要求：
1   实验八 Socket网络编程实验
1.1 实验目的
1) 掌握Sockets的相关基础知识，学习Sockets编程的基本函数和数据类型
2) 掌握UDP、TCP Client/Server模式的通信原理。
3) 掌握socket编程命令
1.2 实验内容
1) 实现一个简单的客户机/服务器程序,基于TCP和UDP协议分别实现。
2) 应用场景为一个验证用户登录的程序。
1.3 实验原理
1.3.1 熟悉TCP，UDP协议原理
略。
1.3.2 Socket网络编程原理
下面简单介绍互联网的Client/Server模式的工作原理，以TCP服务器为例说明，UDP服务器略有不同。客户端也是如此。
1）服务器
服务器先创建一个套接字（Socket），并将该套接字和特定端口绑定，然后服务器开始在此套接字上监听，直到收到一个客户端的连接请求，然后服务器与客户端建立连接，连接成功后和该客户端进行通信（相互接收和发送数据），进行用户信息验证，并返回验证信息。最后，服务器和客户端断开连接，继续在端口上监听。
2）客户端
客户端创建一个套接字，里面包含了服务器的地址和端口号，客户端的端口号由系统自动分配，不需要指明。和服务器建立连接，如果连接成功则socket创建成功。然后客户端发送用户名和密码，等待验证。通信结束后主动断开连接，释放资源。
1.4 实验要求
1）比较TCP DUP两种协议的不同，在实验报告中写出自己的理解；
2）可用多种语言实现，建议 C/C++，JAVA或 Python。
1.5 实验环境和分组
1）每2位同学一组，共编写程序（一人客户端，服务）。
2）编程时请自备电脑编程调试。验收时电脑1台。
1.6 实验步骤
步骤 1：编写server端程序
步骤 2：编写client端程序
步骤 3：client端和 server端实现互联通信， 验证用户登录验证用户登录信息。例如，客户端发送用户名和密码，如若信息正确服务器端返回：送用户名和密码，如若信息正确服务器端返回：送用户名和密码，如若信息正确服务器端返回：“信息正确”；否则，服务器端返回：“用户名或密码错误请再次输入”。（提示信息不唯一，可自由改变）
1.7 结果分析
1) 如何服务器能实现循环监听？
2) 比较两种协议在代码层面的区别。
1.8 互动讨论主题
1) TCP协议和 HTTP协议的区别和联系


udp_sn部分的修改：
原来当客户端给服务器发送file1.docx的请求时，发送部分（elif (data.decode('utf-8') == f1Name):之后以及f2name之前的所有内容）改为：
				        count=0
                                                                        f=open('file1.docx','rb')
                                                                        while True:
                                                                            if count == 0:
                                                                                print ("Are You Ready?")
                                                                            data = f.read(BUFSIZE)
                                                                            if str(data)!="b''":
                                                                                sockSrv.sendto(data,addr)
                                                                            else:
                                                                                sockSrv.sendto('end'.encode('utf-8'),addr) #此处文件结束
                                                                                break

                                                                            #data,addr = sockSrv.recvfrom(BUFSIZE)
                                                                            count+=1
                                                                            print('Sended Successfully!')
定义了count变量，用来控制读取发送文件的次数；文件过大，每次只读出固定大小；（意思就是手动分包）
即BUFSIZE字节大小；由于python传输文件最后没有转义字符，所以空的二进制内容"b''"就是发完了。
服务器就会给客户端发送end。

udp_cn部分的修改：
if (data == f1Name):之后保留了第一行的发送语句，因为这时候键盘输入了文件名，需要告诉服务器，客户端需要哪个文件；
同样也定义了count,用来计算接收的次数；
打开一个新的docx文件；
如果count=0;
说明还没开始传文件，就告诉服务器，客户端准备好了
然后从缓存区读取文件；
如果读到了服务器发来的end,就说明传输完成了，就写入新建的文件；